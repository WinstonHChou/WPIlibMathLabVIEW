<HTML>
<HEAD>
<TITLE>LinearFilter_BackwardFiniteDifference.vi</TITLE>
<META NAME="Author" CONTENT="">
<META NAME="GENERATOR" CONTENT="G Development Environment">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME="LinearFilter_BackwardFiniteDifference.vi"></A><H2>LinearFilter_BackwardFiniteDifference.vi</H2>
<P>Creates a backward finite difference filter that computes the nth derivative of the input given the specified number of samples.</P>
<P></P>
<P>For additional information see:</P>
<P>      https://en.wikipedia.org/wiki/Finite_difference_coefficient#Arbitrary_stencil_points</P>
<P>    </P>
<P>For a given list of stencil points s of length n and the order of derivative d &lt; n, the finite difference coefficients can be obtained by solving the following linear system for the vector a.</P>
<P></P>
<P>     [s1°   ?  s?° ][a1]      [ d0,d ]</P>
<P>     [ ?    ?  ?   ][? ] = d! [  ?   ]</P>
<P>     [s1n?¹ ? s?n?¹][a?]      [d??1,d]</P>
<P>    </P>
<P>    </P>
<P>    where d?,? are the Kronecker delta. For backward finite difference,</P>
<P>    the stencil points are the range [-n + 1, 0]. The FIR gains are the</P>
<P>    elements of the vector a in reverse order divided by h?.</P>
<P>    </P>
<P>    The order of accuracy of the approximation is of the form O(hn??).</P>
<P></P>
<P>Inputs: </P>
<P>   - derivative  --  The order of the derivative to compute.</P>
<P>   - samples  --  The number of samples to use to compute the given derivative. </P>
<P>	This must be one more than the order of derivative or higher.</P>
<P>   - period  --  The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>    - LINEAR FILTER - cluster containing:</P>
<P>             - InputGains - Array of “feedforward” or FIR gain factors (bx)</P>
<P>              - OutputGains - Array of “feedback” or IIR gain factors for feedback terms (ax)</P>
<P>              - Inputs - Array of the last n saved inputs</P>
<P>              - Outputs - Array of the last n saved outputs</P>
<P>              -  InGainCount - Number of input gain terms</P>
<P>              -  OutGainCount - number of output gain terms</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__BackwardFiniteDifferencec.png" ALT="LinearFilter_BackwardFiniteDifference.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>Derivative</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>Samples</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Period</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ibool.png" ALT="ibool"></P>
</TD>
<TD>
<B>Error</B> </TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_Calculate.vi"></A><H2>LinearFilter_Calculate.vi</H2>
<P>Calculates the next value of the filter.  To work correctly this must be called periodically</P>
<P></P>
<P>Inputs:</P>
<P>  - inLinearfilter - Linear filter data structure</P>
<P>  - input - Current input value.</P>
<P>   </P>
<P>Outputs:</P>
<P>  - outLinearfilter - Updated linear filter data structurea</P>
<P>  - output - The filtered value at this step</P>
<P> </P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__Calculatec.png" ALT="LinearFilter_Calculate.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Input</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ccclst.png" ALT="ccclst"></P>
</TD>
<TD>
<B>In LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>Out LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_CutoffFrequency.vi"></A><H2>LinearFilter_CutoffFrequency.vi</H2>
<P>Calculate the cutoff frequency from the time constant.</P>
<P></P>
<P>Inputs:</P>
<P>  - time Constant - seconds</P>
<P></P>
<P>Outputs:</P>
<P>  - cutoff Frequency - hertz</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__CutoffFrequencyc.png" ALT="LinearFilter_CutoffFrequency.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Cutoff Freq</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_Execute.vi"></A><H2>LinearFilter_Execute.vi</H2>
<P>This is a LabVIEW &quot;convience&quot; function that combines the various subVI for a linear filter into a single subVI.  This subVI creates and executes the linear filter.  The filter can be dynamically enabled and disabled.  When the filter is disabled, the input is transfered directly to the output.  Bumpless transfer is provided when enabling the filter.  Bumpless transfer is NOT provided when disabling the filter.  The output value jumps directly to the current input value.  The filter type and filter constants can also be changed dynamically.  When the filter contstants are changed, the output may jump to the current input value when the internal buffers are reset to the current input value.</P>
<P></P>
<P>Inputs:</P>
<P>  - FilterType  -  An enumerated value used to select the type of filter to be cofigured.  The possible values are:</P>
<P>          - Moving Average - Specify the &quot;sample&quot; input.</P>
<P>          - Low pass 1st order Butterworth filter</P>
<P>          - Low pass 2nd order Butterworth filter</P>
<P>          - High pass 1st order Butterworth filter</P>
<P>          - High pass 2nd order Butterworth filter</P>
<P>  - Input  -  Input value to be filtered (Required)  </P>
<P>  - Enable  -  Boolean indicating filtering should be performed (Default = True)</P>
<P>  - TimeConstant  -  Filtering time constant seconds.  Used for all types except Moving </P>
<P>                                    Average (Default = 0.020) </P>
<P>  - SamplePeriod  -  Execution period seconds.  Used for all types except Moving Average.  </P>
<P>                                  (Default = 0.020)</P>
<P>  - Samples  -  Number of samples for the moving average filter.  (Default = 3)</P>
<P></P>
<P>Outputs:</P>
<P>  - OutLinearFilter  -  Current value of the LinearFilter data structure.</P>
<P>  - Output  -  Current output value.</P>
<P> </P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__Executec.png" ALT="LinearFilter_Execute.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Input</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cbool.png" ALT="cbool"></P>
</TD>
<TD>
<B>Enable</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cenum.png" ALT="cenum"></P>
</TD>
<TD>
<B>Filter Type</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>Samples</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>Out LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_HighPass.vi"></A><H2>LinearFilter_HighPass.vi</H2>
<P> </P>
<P>Creates a first-order high-pass filter of the form: </P>
<P></P>
<P>    y[n] = gain*x[n] + (-gain)*x[n-1] + gain*y[n-1] </P>
<P></P>
<P>    where </P>
<P></P>
<P>        gain = e^(-dt / T), </P>
<P>        T is the time constant in seconds.</P>
<P>   </P>
<P>This filter is stable for time constants greater than zero.</P>
<P>   </P>
<P>Inputs:</P>
<P>  - timeConstant The discrete-time time constant in seconds.</P>
<P>  - samplePeriod       The period in seconds between samples taken by the user.</P>
<P>   </P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__HighPassc.png" ALT="LinearFilter_HighPass.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_HighPassBW1.vi"></A><H2>LinearFilter_HighPassBW1.vi</H2>
<P>Creates a 1st order Butterworth high pass filter.</P>
<P></P>
<P>More information on this type of filter can be found at:</P>
<P></P>
<P>    https://en.wikipedia.org/wiki/Butterworth_filter</P>
<P></P>
<P>Inputs:    </P>
<P>  - timeConstant - The discrete-time time constant in seconds.</P>
<P>  -samplePeriod  - The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__HighPassBW1c.png" ALT="LinearFilter_HighPassBW1.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_HighPassBW2.vi"></A><H2>LinearFilter_HighPassBW2.vi</H2>
<P>Creates a 2nd order Butterworth high pass filter.</P>
<P></P>
<P>A 2nd order filter provides more filtering, however it also has a larger phase shift (time delay).</P>
<P></P>
<P>More information on this type of filter can be found at:</P>
<P></P>
<P>    https://en.wikipedia.org/wiki/Butterworth_filter</P>
<P></P>
<P>Inputs:    </P>
<P>  - timeConstant - The discrete-time time constant in seconds.</P>
<P>  - samplePeriod  - The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__HighPassBW2c.png" ALT="LinearFilter_HighPassBW2.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_LowPassBW1.vi"></A><H2>LinearFilter_LowPassBW1.vi</H2>
<P>Creates a 1st order Butterworth low pass filter.</P>
<P></P>
<P>More information on this type of filter can be found at:</P>
<P></P>
<P>    https://en.wikipedia.org/wiki/Butterworth_filter</P>
<P></P>
<P>Inputs:    </P>
<P>  - timeConstant - The discrete-time time constant in seconds.</P>
<P>  -samplePeriod  - The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>  - LinearFilter - Created datat structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__LowPassBW1c.png" ALT="LinearFilter_LowPassBW1.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_LowPassBW2.vi"></A><H2>LinearFilter_LowPassBW2.vi</H2>
<P>Creates a 2nd order Butterworth low pass filter.</P>
<P></P>
<P>A 2nd order filter provides more filtering, however it also has a larger phase shift (time delay).</P>
<P></P>
<P>More information on this type of filter can be found at:</P>
<P></P>
<P>    https://en.wikipedia.org/wiki/Butterworth_filter</P>
<P></P>
<P>Inputs:    </P>
<P>  - timeConstant - The discrete-time time constant in seconds.</P>
<P>  - samplePeriod  - The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__LowPassBW2c.png" ALT="LinearFilter_LowPassBW2.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_MovingAverage.vi"></A><H2>LinearFilter_MovingAverage.vi</H2>
<P>Creates a K-tap FIR moving average filter of the form: </P>
<P></P>
<P>    y[n] = 1/k * (x[k] + x[k-1] + ... + x[0]).</P>
<P>   </P>
<P>This filter is always stable.</P>
<P>   </P>
<P>Inputs:    </P>
<P>    - Samples - The number of samples to average over. Higher = smoother but slower.</P>
<P>      The number of samples must be &gt;= 1</P>
<P></P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P>  - Error  --  If TRUE, an error occured.</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__MovingAveragec.png" ALT="LinearFilter_MovingAverage.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>Samples</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ibool.png" ALT="ibool"></P>
</TD>
<TD>
<B>Error</B> </TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_New.vi"></A><H2>LinearFilter_New.vi</H2>
<P>This VI creates a new data structure (cluster) that stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>y[n] is the output at time &quot;n&quot; </P>
<P>x[n] is the input at time &quot;n&quot; </P>
<P>y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P> </P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>- Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>- Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>- Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>- If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
<P></P>
<P>Inputs: </P>
<P>  - InputGains - Array of “feedforward” or FIR gain factors (bx)</P>
<P></P>
<P>  - OutputGains - Array of “feedback” or IIR gain factors for feedback terms (ax)</P>
<P></P>
<P>Outputs:</P>
<P>    - LINEAR FILTER - cluster containing:</P>
<P>             - InputGains - Array of “feedforward” or FIR gain factors (bx)</P>
<P>              - OutputGains - Array of “feedback” or IIR gain factors for feedback terms (ax)</P>
<P>              - Inputs - Array of the last n saved inputs</P>
<P>              - Outputs - Array of the last n saved outputs</P>
<P>              -  InGainCount - Number of input gain terms</P>
<P>              -  OutGainCount - number of output gain terms</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__Newc.png" ALT="LinearFilter_New.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> </TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> </TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_Reset.vi"></A><H2>LinearFilter_Reset.vi</H2>
<P>Reset the filter state.  Sets the saved inputs and outputs to zero.</P>
<P></P>
<P></P>
<P>Inputs:    </P>
<P>  - inLinearfilter - Linear filter data structure</P>
<P></P>
<P>Outputs:</P>
<P>  - outLinearfilter - Updated linear filter data structure</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__Resetc.png" ALT="LinearFilter_Reset.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ccclst.png" ALT="ccclst"></P>
</TD>
<TD>
<B>In LINEAR_FILTER </B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>Out LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_ResetToValue.vi"></A><H2>LinearFilter_ResetToValue.vi</H2>
<P>Reset the filter state.  Sets the saved inputs and outputs to &quot;InputValue:&quot;</P>
<P></P>
<P></P>
<P>Inputs:    </P>
<P>  - inLinearfilter - Linear filter data structure</P>
<P>  - InputValue - This value is used to fill the saved input and output values</P>
<P></P>
<P>Outputs:</P>
<P>  - outLinearfilter - Updated linear filter data structurea</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__ResetToValuec.png" ALT="LinearFilter_ResetToValue.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ccclst.png" ALT="ccclst"></P>
</TD>
<TD>
<B>In LINEAR_FILTER </B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="c1ddbl.png" ALT="c1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ci32.png" ALT="ci32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>InputValue</B> </TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>Out LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<HR>
<A NAME="LinearFilter_SinglePoleIIR.vi"></A><H2>LinearFilter_SinglePoleIIR.vi</H2>
<P>Creates a one-pole IIR low-pass filter of the form: </P>
<P></P>
<P>    y[n] = (1-gain)*x[n] + gain*y[n-1] </P>
<P></P>
<P>    where </P>
<P>         gain = e^(-dt / T), </P>
<P>         T is the time constant in seconds.</P>
<P>   </P>
<P>This filter is stable for time constants greater than zero.</P>
<P></P>
<P>Inputs:    </P>
<P>  - timeConstant - The discrete-time time constant in seconds.</P>
<P>  -samplePeriod  - The period in seconds between samples taken by the user.</P>
<P></P>
<P>Outputs:</P>
<P>  - Linearfilter - Created datat structure</P>
<P>  - Cutoff Frequency - Frequency (Hz)</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__SinglePoleIIRc.png" ALT="LinearFilter_SinglePoleIIR.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>TimeConstant</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>SamplePeriod</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="icclst.png" ALT="icclst"></P>
</TD>
<TD>
<B>LINEAR_FILTER</B> <P>This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.</P>
<P> </P>
<P>Filters are of the form: </P>
<P>	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])</P>
<P> </P>
<P>Where: </P>
<P>  -  y[n] is the output at time &quot;n&quot; </P>
<P>  -  x[n] is the input at time &quot;n&quot; </P>
<P>  -  y[n-1] is the output from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  x[n-1] is the input from the LAST time step (&quot;n-1&quot;) </P>
<P>  -  b0...bP are the &quot;feedforward&quot; (FIR) gains </P>
<P>  -  a0...aQ are the &quot;feedback&quot; (IIR) gains </P>
<P></P>
<P>IMPORTANT! Note the &quot;-&quot; sign in front of the feedback term! This is a common convention in signal processing.</P>
<P></P>
<P>What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A &quot;low pass&quot; filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a &quot;high pass&quot; filter gets rid of slow-moving signal components, letting you detect large changes more easily.</P>
<P> </P>
<P>Example FRC applications of filters: </P>
<P>  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)</P>
<P>  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping</P>
<P>  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components</P>
<P>  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)</P>
<P> </P>
<P>For more on filters, we highly recommend the following articles:</P>
<P>	https://en.wikipedia.org/wiki/Linear_filter</P>
<P>	https://en.wikipedia.org/wiki/Iir_filter</P>
<P>	https://en.wikipedia.org/wiki/Fir_filter</P>
<P> </P>
<P>Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.</P>
<P> </P>
<P>Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>InputGains</B> <P>Array of “feedforward” or FIR gain factors (bx)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>InputGain</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>OutputGains</B> <P>Array of “feedback” or IIR gain factors  (ax)</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>OutputGain</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Inputs</B> <P>Array of the last n saved inputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Input</B> <P>The rotation angle (Radians)</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="i1ddbl.png" ALT="i1ddbl"></P>
</TD>
<TD>
<B>Outputs</B> <P>Array of the last n saved outputs</P>
</TD>
</TR>
</Table>
<UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Output</B> <P>The sine of the rotation angle.</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>InGainCount</B> <P>Number of input gain terms</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="ii32.png" ALT="ii32"></P>
</TD>
<TD>
<B>OutGainCount</B> <P>number of output gain terms</P>
</TD>
</TR>
</Table>
</UL>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Cutoff Freq</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<HR>
<A NAME="LinearFilter_TimeConst.vi"></A><H2>LinearFilter_TimeConst.vi</H2>
<P>Calculate the time constant from the cutoff frequency</P>
<P></P>
<P>Inputs:</P>
<P>  - cutoff Frequency - hertz</P>
<P></P>
<P>Outputs:</P>
<P>  - time Constant - seconds</P>
<P><IMG SRC="Trajectory__Library_lvlib_LinearFilter__TimeConstc.png" ALT="LinearFilter_TimeConst.vi"></P>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="cdbl.png" ALT="cdbl"></P>
</TD>
<TD>
<B>Cutoff Freq</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
<Table>
<TR valign=TOP>
<TD>
<P><IMG SRC="idbl.png" ALT="idbl"></P>
</TD>
<TD>
<B>Time Const</B> <P>The cosine of the rotation angle</P>
</TD>
</TR>
</Table>
</BODY>
</HTML>
